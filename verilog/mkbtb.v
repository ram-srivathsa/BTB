//
// Generated by Bluespec Compiler, version 2017.07.A (build 1da80f1, 2017-07-21)
//
// On Tue Jun 12 11:12:33 IST 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_ma_put                     O     1 const
// mn_get                         O    35
// RDY_mn_get                     O     1
// RDY_ma_update                  O     1
// RDY_ma_flush                   O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_put_pc                      I    32 reg
// ma_update_pc                   I    32
// ma_update_branch_imm           I    12
// ma_update_way_num              I     2
// EN_ma_put                      I     1
// EN_ma_update                   I     1
// EN_ma_flush                    I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkbtb(CLK,
	     RST_N,

	     ma_put_pc,
	     EN_ma_put,
	     RDY_ma_put,

	     mn_get,
	     RDY_mn_get,

	     ma_update_pc,
	     ma_update_branch_imm,
	     ma_update_way_num,
	     EN_ma_update,
	     RDY_ma_update,

	     EN_ma_flush,
	     RDY_ma_flush);
  input  CLK;
  input  RST_N;

  // action method ma_put
  input  [31 : 0] ma_put_pc;
  input  EN_ma_put;
  output RDY_ma_put;

  // value method mn_get
  output [34 : 0] mn_get;
  output RDY_mn_get;

  // action method ma_update
  input  [31 : 0] ma_update_pc;
  input  [11 : 0] ma_update_branch_imm;
  input  [1 : 0] ma_update_way_num;
  input  EN_ma_update;
  output RDY_ma_update;

  // action method ma_flush
  input  EN_ma_flush;
  output RDY_ma_flush;

  // signals for module outputs
  wire [34 : 0] mn_get;
  wire RDY_ma_flush, RDY_ma_put, RDY_ma_update, RDY_mn_get;

  // inlined wires
  reg wr_hit$wget;
  wire wr_way_num$whas;

  // register rg_flush
  reg rg_flush;
  wire rg_flush$D_IN, rg_flush$EN;

  // register rg_flush_addr
  reg [8 : 0] rg_flush_addr;
  wire [8 : 0] rg_flush_addr$D_IN;
  wire rg_flush_addr$EN;

  // register rg_pc_copy
  reg [31 : 0] rg_pc_copy;
  wire [31 : 0] rg_pc_copy$D_IN;
  wire rg_pc_copy$EN;

  // ports of submodule bram_replacement
  wire [7 : 0] bram_replacement$ADDRA, bram_replacement$ADDRB;
  wire [1 : 0] bram_replacement$DIA,
	       bram_replacement$DIB,
	       bram_replacement$DOA;
  wire bram_replacement$ENA,
       bram_replacement$ENB,
       bram_replacement$WEA,
       bram_replacement$WEB;

  // ports of submodule bram_way1
  wire [34 : 0] bram_way1$DIA, bram_way1$DIB, bram_way1$DOA;
  wire [7 : 0] bram_way1$ADDRA, bram_way1$ADDRB;
  wire bram_way1$ENA, bram_way1$ENB, bram_way1$WEA, bram_way1$WEB;

  // ports of submodule bram_way2
  wire [34 : 0] bram_way2$DIA, bram_way2$DIB, bram_way2$DOA;
  wire [7 : 0] bram_way2$ADDRA, bram_way2$ADDRB;
  wire bram_way2$ENA, bram_way2$ENB, bram_way2$WEA, bram_way2$WEB;

  // ports of submodule bram_way3
  wire [34 : 0] bram_way3$DIA, bram_way3$DIB, bram_way3$DOA;
  wire [7 : 0] bram_way3$ADDRA, bram_way3$ADDRB;
  wire bram_way3$ENA, bram_way3$ENB, bram_way3$WEA, bram_way3$WEB;

  // ports of submodule bram_way4
  wire [34 : 0] bram_way4$DIA, bram_way4$DIB, bram_way4$DOA;
  wire [7 : 0] bram_way4$ADDRA, bram_way4$ADDRB;
  wire bram_way4$ENA, bram_way4$ENB, bram_way4$WEA, bram_way4$WEB;

  // inputs to muxes for submodule ports
  wire [34 : 0] MUX_bram_way1$b_put_3__VAL_1;
  wire [8 : 0] MUX_rg_flush_addr$write_1__VAL_1;
  wire [1 : 0] MUX_bram_replacement$b_put_3__VAL_2;
  wire MUX_bram_replacement$b_put_1__SEL_1,
       MUX_bram_way1$b_put_1__SEL_1,
       MUX_bram_way2$b_put_1__SEL_1,
       MUX_bram_way3$b_put_1__SEL_1,
       MUX_bram_way4$b_put_1__SEL_1,
       MUX_rg_flush$write_1__SEL_1;

  // remaining internal signals
  reg [31 : 0] mn_get_branch_pc__h3066;
  reg [1 : 0] mn_get_way_num__h3065;
  wire [31 : 0] new_value__h1833,
		new_value__h1914,
		new_value__h1980,
		new_value__h2046,
		x__h1860,
		x__h1926,
		x__h1992,
		x__h2058;
  wire [3 : 0] x__h1416;
  wire lv_compare1__h1405,
       lv_compare2__h1406,
       lv_compare3__h1407,
       lv_compare4__h1408;

  // action method ma_put
  assign RDY_ma_put = 1'd1 ;

  // value method mn_get
  assign mn_get =
	     { wr_hit$wget, mn_get_way_num__h3065, mn_get_branch_pc__h3066 } ;
  assign RDY_mn_get = wr_way_num$whas && wr_way_num$whas && wr_way_num$whas ;

  // action method ma_update
  assign RDY_ma_update = !rg_flush ;

  // action method ma_flush
  assign RDY_ma_flush = !rg_flush ;

  // submodule bram_replacement
  BRAM2Load #(.FILENAME("repl.dump"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd8),
	      .DATA_WIDTH(32'd2),
	      .MEMSIZE(9'd256),
	      .BINARY(1'd1)) bram_replacement(.CLKA(CLK),
					      .CLKB(CLK),
					      .ADDRA(bram_replacement$ADDRA),
					      .ADDRB(bram_replacement$ADDRB),
					      .DIA(bram_replacement$DIA),
					      .DIB(bram_replacement$DIB),
					      .WEA(bram_replacement$WEA),
					      .WEB(bram_replacement$WEB),
					      .ENA(bram_replacement$ENA),
					      .ENB(bram_replacement$ENB),
					      .DOA(bram_replacement$DOA),
					      .DOB());

  // submodule bram_way1
  BRAM2Load #(.FILENAME("way1.dump"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd8),
	      .DATA_WIDTH(32'd35),
	      .MEMSIZE(9'd256),
	      .BINARY(1'd1)) bram_way1(.CLKA(CLK),
				       .CLKB(CLK),
				       .ADDRA(bram_way1$ADDRA),
				       .ADDRB(bram_way1$ADDRB),
				       .DIA(bram_way1$DIA),
				       .DIB(bram_way1$DIB),
				       .WEA(bram_way1$WEA),
				       .WEB(bram_way1$WEB),
				       .ENA(bram_way1$ENA),
				       .ENB(bram_way1$ENB),
				       .DOA(bram_way1$DOA),
				       .DOB());

  // submodule bram_way2
  BRAM2Load #(.FILENAME("way2.dump"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd8),
	      .DATA_WIDTH(32'd35),
	      .MEMSIZE(9'd256),
	      .BINARY(1'd1)) bram_way2(.CLKA(CLK),
				       .CLKB(CLK),
				       .ADDRA(bram_way2$ADDRA),
				       .ADDRB(bram_way2$ADDRB),
				       .DIA(bram_way2$DIA),
				       .DIB(bram_way2$DIB),
				       .WEA(bram_way2$WEA),
				       .WEB(bram_way2$WEB),
				       .ENA(bram_way2$ENA),
				       .ENB(bram_way2$ENB),
				       .DOA(bram_way2$DOA),
				       .DOB());

  // submodule bram_way3
  BRAM2Load #(.FILENAME("way3.dump"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd8),
	      .DATA_WIDTH(32'd35),
	      .MEMSIZE(9'd256),
	      .BINARY(1'd1)) bram_way3(.CLKA(CLK),
				       .CLKB(CLK),
				       .ADDRA(bram_way3$ADDRA),
				       .ADDRB(bram_way3$ADDRB),
				       .DIA(bram_way3$DIA),
				       .DIB(bram_way3$DIB),
				       .WEA(bram_way3$WEA),
				       .WEB(bram_way3$WEB),
				       .ENA(bram_way3$ENA),
				       .ENB(bram_way3$ENB),
				       .DOA(bram_way3$DOA),
				       .DOB());

  // submodule bram_way4
  BRAM2Load #(.FILENAME("way4.dump"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd8),
	      .DATA_WIDTH(32'd35),
	      .MEMSIZE(9'd256),
	      .BINARY(1'd1)) bram_way4(.CLKA(CLK),
				       .CLKB(CLK),
				       .ADDRA(bram_way4$ADDRA),
				       .ADDRB(bram_way4$ADDRB),
				       .DIA(bram_way4$DIA),
				       .DIB(bram_way4$DIB),
				       .WEA(bram_way4$WEA),
				       .WEB(bram_way4$WEB),
				       .ENA(bram_way4$ENA),
				       .ENB(bram_way4$ENB),
				       .DOA(bram_way4$DOA),
				       .DOB());

  // inputs to muxes for submodule ports
  assign MUX_bram_replacement$b_put_1__SEL_1 = rg_flush && !rg_flush_addr[8] ;
  assign MUX_bram_way1$b_put_1__SEL_1 =
	     EN_ma_update && ma_update_way_num == 2'b0 ;
  assign MUX_bram_way2$b_put_1__SEL_1 =
	     EN_ma_update && ma_update_way_num == 2'b01 ;
  assign MUX_bram_way3$b_put_1__SEL_1 =
	     EN_ma_update && ma_update_way_num == 2'b10 ;
  assign MUX_bram_way4$b_put_1__SEL_1 =
	     EN_ma_update && ma_update_way_num == 2'b11 ;
  assign MUX_rg_flush$write_1__SEL_1 = rg_flush && rg_flush_addr[8] ;
  assign MUX_bram_replacement$b_put_3__VAL_2 = ma_update_way_num + 2'd1 ;
  assign MUX_bram_way1$b_put_3__VAL_1 =
	     { ma_update_pc[31:10], ma_update_branch_imm, 1'b1 } ;
  assign MUX_rg_flush_addr$write_1__VAL_1 = rg_flush_addr + 9'd1 ;

  // inlined wires
  assign wr_way_num$whas =
	     x__h1416 == 4'b1000 || x__h1416 == 4'b0100 ||
	     x__h1416 == 4'b0010 ||
	     x__h1416 == 4'b0001 ||
	     x__h1416 == 4'b0 ;
  always@(x__h1416 or
	  bram_way4$DOA or bram_way3$DOA or bram_way2$DOA or bram_way1$DOA)
  begin
    case (x__h1416)
      4'b0010: wr_hit$wget = bram_way3$DOA[0];
      4'b0100: wr_hit$wget = bram_way2$DOA[0];
      4'b1000: wr_hit$wget = bram_way1$DOA[0];
      default: wr_hit$wget = x__h1416 == 4'b0001 && bram_way4$DOA[0];
    endcase
  end

  // register rg_flush
  assign rg_flush$D_IN = !MUX_rg_flush$write_1__SEL_1 ;
  assign rg_flush$EN = rg_flush && rg_flush_addr[8] || EN_ma_flush ;

  // register rg_flush_addr
  assign rg_flush_addr$D_IN =
	     MUX_bram_replacement$b_put_1__SEL_1 ?
	       MUX_rg_flush_addr$write_1__VAL_1 :
	       9'd0 ;
  assign rg_flush_addr$EN = rg_flush && !rg_flush_addr[8] || EN_ma_flush ;

  // register rg_pc_copy
  assign rg_pc_copy$D_IN = ma_put_pc ;
  assign rg_pc_copy$EN = EN_ma_put ;

  // submodule bram_replacement
  assign bram_replacement$ADDRA = ma_put_pc[9:2] ;
  assign bram_replacement$ADDRB =
	     MUX_bram_replacement$b_put_1__SEL_1 ?
	       rg_flush_addr[7:0] :
	       ma_update_pc[9:2] ;
  assign bram_replacement$DIA = 2'b10 /* unspecified value */  ;
  assign bram_replacement$DIB =
	     MUX_bram_replacement$b_put_1__SEL_1 ?
	       2'd0 :
	       MUX_bram_replacement$b_put_3__VAL_2 ;
  assign bram_replacement$WEA = 1'd0 ;
  assign bram_replacement$WEB = 1'd1 ;
  assign bram_replacement$ENA = EN_ma_put ;
  assign bram_replacement$ENB =
	     rg_flush && !rg_flush_addr[8] || EN_ma_update ;

  // submodule bram_way1
  assign bram_way1$ADDRA = ma_put_pc[9:2] ;
  assign bram_way1$ADDRB =
	     MUX_bram_way1$b_put_1__SEL_1 ?
	       ma_update_pc[9:2] :
	       rg_flush_addr[7:0] ;
  assign bram_way1$DIA = 35'h2AAAAAAAA /* unspecified value */  ;
  assign bram_way1$DIB =
	     MUX_bram_way1$b_put_1__SEL_1 ?
	       MUX_bram_way1$b_put_3__VAL_1 :
	       35'd0 ;
  assign bram_way1$WEA = 1'd0 ;
  assign bram_way1$WEB = 1'd1 ;
  assign bram_way1$ENA = EN_ma_put ;
  assign bram_way1$ENB =
	     EN_ma_update && ma_update_way_num == 2'b0 ||
	     rg_flush && !rg_flush_addr[8] ;

  // submodule bram_way2
  assign bram_way2$ADDRA = ma_put_pc[9:2] ;
  assign bram_way2$ADDRB =
	     MUX_bram_way2$b_put_1__SEL_1 ?
	       ma_update_pc[9:2] :
	       rg_flush_addr[7:0] ;
  assign bram_way2$DIA = 35'h2AAAAAAAA /* unspecified value */  ;
  assign bram_way2$DIB =
	     MUX_bram_way2$b_put_1__SEL_1 ?
	       MUX_bram_way1$b_put_3__VAL_1 :
	       35'd0 ;
  assign bram_way2$WEA = 1'd0 ;
  assign bram_way2$WEB = 1'd1 ;
  assign bram_way2$ENA = EN_ma_put ;
  assign bram_way2$ENB =
	     EN_ma_update && ma_update_way_num == 2'b01 ||
	     rg_flush && !rg_flush_addr[8] ;

  // submodule bram_way3
  assign bram_way3$ADDRA = ma_put_pc[9:2] ;
  assign bram_way3$ADDRB =
	     MUX_bram_way3$b_put_1__SEL_1 ?
	       ma_update_pc[9:2] :
	       rg_flush_addr[7:0] ;
  assign bram_way3$DIA = 35'h2AAAAAAAA /* unspecified value */  ;
  assign bram_way3$DIB =
	     MUX_bram_way3$b_put_1__SEL_1 ?
	       MUX_bram_way1$b_put_3__VAL_1 :
	       35'd0 ;
  assign bram_way3$WEA = 1'd0 ;
  assign bram_way3$WEB = 1'd1 ;
  assign bram_way3$ENA = EN_ma_put ;
  assign bram_way3$ENB =
	     EN_ma_update && ma_update_way_num == 2'b10 ||
	     rg_flush && !rg_flush_addr[8] ;

  // submodule bram_way4
  assign bram_way4$ADDRA = ma_put_pc[9:2] ;
  assign bram_way4$ADDRB =
	     MUX_bram_way4$b_put_1__SEL_1 ?
	       ma_update_pc[9:2] :
	       rg_flush_addr[7:0] ;
  assign bram_way4$DIA = 35'h2AAAAAAAA /* unspecified value */  ;
  assign bram_way4$DIB =
	     MUX_bram_way4$b_put_1__SEL_1 ?
	       MUX_bram_way1$b_put_3__VAL_1 :
	       35'd0 ;
  assign bram_way4$WEA = 1'd0 ;
  assign bram_way4$WEB = 1'd1 ;
  assign bram_way4$ENA = EN_ma_put ;
  assign bram_way4$ENB =
	     EN_ma_update && ma_update_way_num == 2'b11 ||
	     rg_flush && !rg_flush_addr[8] ;

  // remaining internal signals
  assign lv_compare1__h1405 = bram_way1$DOA[34:13] == rg_pc_copy[31:10] ;
  assign lv_compare2__h1406 = bram_way2$DOA[34:13] == rg_pc_copy[31:10] ;
  assign lv_compare3__h1407 = bram_way3$DOA[34:13] == rg_pc_copy[31:10] ;
  assign lv_compare4__h1408 = bram_way4$DOA[34:13] == rg_pc_copy[31:10] ;
  assign new_value__h1833 = x__h1860 + rg_pc_copy ;
  assign new_value__h1914 = x__h1926 + rg_pc_copy ;
  assign new_value__h1980 = x__h1992 + rg_pc_copy ;
  assign new_value__h2046 = x__h2058 + rg_pc_copy ;
  assign x__h1416 =
	     { lv_compare1__h1405,
	       lv_compare2__h1406,
	       lv_compare3__h1407,
	       lv_compare4__h1408 } ;
  assign x__h1860 = { 20'd0, bram_way1$DOA[12:1] } ;
  assign x__h1926 = { 20'd0, bram_way2$DOA[12:1] } ;
  assign x__h1992 = { 20'd0, bram_way3$DOA[12:1] } ;
  assign x__h2058 = { 20'd0, bram_way4$DOA[12:1] } ;
  always@(x__h1416 or bram_replacement$DOA)
  begin
    case (x__h1416)
      4'b0001: mn_get_way_num__h3065 = 2'b11;
      4'b0010: mn_get_way_num__h3065 = 2'b10;
      4'b0100: mn_get_way_num__h3065 = 2'b01;
      4'b1000: mn_get_way_num__h3065 = 2'b0;
      default: mn_get_way_num__h3065 = bram_replacement$DOA;
    endcase
  end
  always@(x__h1416 or
	  new_value__h2046 or
	  new_value__h1980 or new_value__h1914 or new_value__h1833)
  begin
    case (x__h1416)
      4'b0010: mn_get_branch_pc__h3066 = new_value__h1980;
      4'b0100: mn_get_branch_pc__h3066 = new_value__h1914;
      4'b1000: mn_get_branch_pc__h3066 = new_value__h1833;
      default: mn_get_branch_pc__h3066 = new_value__h2046;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_flush <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_flush_addr <= `BSV_ASSIGNMENT_DELAY 9'd0;
	rg_pc_copy <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (rg_flush$EN) rg_flush <= `BSV_ASSIGNMENT_DELAY rg_flush$D_IN;
	if (rg_flush_addr$EN)
	  rg_flush_addr <= `BSV_ASSIGNMENT_DELAY rg_flush_addr$D_IN;
	if (rg_pc_copy$EN)
	  rg_pc_copy <= `BSV_ASSIGNMENT_DELAY rg_pc_copy$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_flush = 1'h0;
    rg_flush_addr = 9'h0AA;
    rg_pc_copy = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkbtb

